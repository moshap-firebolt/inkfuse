#ifndef INKFUSE_SUBOPERATOR_H
#define INKFUSE_SUBOPERATOR_H

#include <vector>

namespace inkfuse {

    struct DiscreteParameter;
    struct InfiniteParameter;

    /// Where in a pipeline can this sub-operator occurr? Depending on the suboperator type,
    /// the central fragment generator produces vectorized primitives in different ways.
    /// For example, an intermediate suboperator will be generated by hooking it into the following
    /// operator DAG:
    ///      FuseSource -> Intermediate -> FuseSink
    /// Meanwhile, the source and sink operators will have the FuseSource and FuseSink operators removed, respectively.
    enum class SuboperatorType {
        /// A source operator which does not operate on a vectorized chunk of data (e.g. HT read)
        Source,
        /// An intermediate operator which reads from a vectorized chunk of data and writes to one (e.g. filter)
        Intermediate,
        /// A sink operator which operators on a vectorized chunk of data and feeds it into some other state (e.g. aggregate insert)
        Sink,
    };

    /// A suboperator is a fragment of a central operator which has a corresponding vectorized primitive.
    /// An example might be the aggregation of an IU into some aggregation state.
    /// An operator can be a DAG of these fragments which can either be interpreted through the vectorized
    /// primitives or fused together.
    ///
    /// A suboperator is parametrized in two different ways:
    /// - Discrete DoF: the suboperator is parametrized over a finite set of potential values. Examples might be
    ///                 SQL types like UInt8, Date, Timestamp, ...
    /// - Infinite DoF: the suboperator is parametrized over an infinite set of potential values. Examples might be
    ///                 the length of a varchar type, or the offset into an aggregation state.
    ///
    /// When defining a suboperator, we define both the discrete and infinite degrees of freedom.
    /// These are used by the central FragmentGenerator
    struct Suboperator {

        struct SuboperatorParams {
            std::vector<DiscreteParameter> param_discrete;
            std::vector<InfiniteParameter> param_infinite;
            SuboperatorType type
        };


        /// Suboperator constructor. Parametrized as described above and also fitting a certain type.
        Suboperator(SuboperatorParams params_): params(std::move(params_)) {};

        /*
         * TODO hooked into larger opartor structure and supporting some form of produce/consume.
         * But we will probably have a hierarchical form of produce consume ...
         * You either interpret an operator at suboperator granularity through pre-compiled fragments or
         * JIT the full operator including all suboperators.
         */

        SuboperatorParams params;

    };

}

#endif //INKFUSE_SUBOPERATOR_H
